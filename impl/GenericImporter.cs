using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using System;
using System.Net.Http;
using System.Threading.Tasks;

namespace Company.Function
{
    public class GenericImporter : IImporter
    {
        private readonly ILogger _logger;

        private readonly IVectorStore _vectorStore;

        private readonly HttpClient _httpClient;

        private const string ApiUrl = "https://api.example.com";

        private const string IndexName = "generic-data";

        private readonly IEmbeddings _embeddingsGenerator;

        private readonly IChunker _chunker;

        public GenericImporter(ILogger<GenericImporter> logger, IVectorStore vectorStore, IEmbeddings embeddingsGenerator, IChunker chunker)
        {
            _logger = logger;
            _vectorStore = vectorStore;
            _httpClient = new HttpClient();
            _embeddingsGenerator = embeddingsGenerator;
            _chunker = chunker;
        }

        public async Task ImportAsync()
        {
            var data = await GetDataAsync();

            var chunks = _chunker.Chunk(data.Description);
            if (chunks == null)
            {
                return;
            }
            var test = await _embeddingsGenerator.GetEmbeddingAsync(chunks);

            _vectorStore.CreateIndex<GenericDataObject>(IndexName);
            await _vectorStore.AddDocumentAsync(IndexName, new List<GenericDataObject> { data });
        }

        public async Task<GenericDataObject> GetDataAsync()
        {
           /* HttpResponseMessage response = await _httpClient.GetAsync(ApiUrl);

            if (response.IsSuccessStatusCode)
            {
                string responseData = await response.Content.ReadAsStringAsync();
                var deserializedObject = JsonConvert.DeserializeObject<GenericDataObject>(responseData);
                if (deserializedObject != null)
                {
                    return deserializedObject;
                }
                else
                {
                    throw new Exception("Failed to deserialize API response.");
                }
            }
            else
            {
                throw new Exception($"Failed to call API. Status code: {response.StatusCode}");
            }
            */

            return new GenericDataObject
            {
                Id = "1",
                Name = "Test Object",
                Description = @"Container Apps application logs consist of two different categories:

                                Container console output (stdout/stderr) messages.
                                System logs generated by Azure Container Apps.
                                Spring App console logs.
                                You can choose between these logs destinations:

                                Log Analytics: Azure Monitor Log Analytics is the default storage and viewing option. Your logs are stored in a Log Analytics workspace where they can be viewed and analyzed using Log Analytics queries. To learn more about Log Analytics, see Azure Monitor Log Analytics.
                                Azure Monitor: Azure Monitor routes logs to one or more destinations:
                                Log Analytics workspace for viewing and analysis.
                                Azure storage account to archive.
                                Azure event hub for data ingestion and analytic services. For more information, see Azure Event Hubs.
                                An Azure partner monitoring solution such as, Datadog, Elastic, Logz.io and others. For more information, see Partner solutions.
                                None: You can disable the storage of log data. When disabled, you can still view real-time container logs via the Logs stream feature in your container app. For more information, see Log streaming.
                                When None or the Azure Monitor destination is selected, the Logs menu item providing the Log Analytics query editor in the Azure portal is disabled.",
            };
        }
    }
}